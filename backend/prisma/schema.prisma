// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(cuid())
  displayName String
  email       String?  @unique
  pronouns    String?
  consentToRecording Boolean @default(false)
  isAnonymous Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  meetingParticipants MeetingParticipant[]
  queueItems          QueueItem[]
  proposals           Proposal[]
  votes               Vote[]
  incidentReports     IncidentReport[]

  @@map("users")
}

model Meeting {
  id          String   @id @default(cuid())
  title       String
  description String?
  pin         String?  @unique
  isActive    Boolean  @default(true)
  settings    Json     // Meeting settings as JSON
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  participants MeetingParticipant[]
  queueItems   QueueItem[]
  proposals    Proposal[]
  incidents    IncidentReport[]

  @@map("meetings")
}

model MeetingParticipant {
  id        String      @id @default(cuid())
  meetingId String
  userId    String
  role      ParticipantRole
  joinedAt  DateTime    @default(now())
  leftAt    DateTime?

  // Relations
  meeting Meeting @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([meetingId, userId])
  @@map("meeting_participants")
}

model QueueItem {
  id          String      @id @default(cuid())
  meetingId   String
  userId      String
  type        QueueItemType
  status      QueueItemStatus @default(WAITING)
  metadata    Json        // Tags, rationale, etc.
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  startedAt   DateTime?
  completedAt DateTime?

  // Relations
  meeting Meeting @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("queue_items")
}

model Proposal {
  id          String   @id @default(cuid())
  meetingId   String
  proposerId  String
  title       String
  description String
  status      ProposalStatus @default(ACTIVE)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  decidedAt   DateTime?

  // Relations
  meeting  Meeting @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  proposer User    @relation(fields: [proposerId], references: [id], onDelete: Cascade)
  votes    Vote[]

  @@map("proposals")
}

model Vote {
  id         String   @id @default(cuid())
  proposalId String
  userId     String
  voteType   VoteType
  rationale  String?
  createdAt  DateTime @default(now())

  // Relations
  proposal Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([proposalId, userId])
  @@map("votes")
}

model IncidentReport {
  id          String   @id @default(cuid())
  meetingId   String
  reporterId  String
  description String
  status      IncidentStatus @default(OPEN)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  meeting  Meeting @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  reporter User    @relation(fields: [reporterId], references: [id], onDelete: Cascade)

  @@map("incident_reports")
}

enum ParticipantRole {
  FACILITATOR
  STACK_KEEPER
  PARTICIPANT
  OBSERVER
}

enum QueueItemType {
  HAND
  DIRECT_RESPONSE
  POINT_PROCESS
  POINT_INFO
  POINT_CLARIFICATION
}

enum QueueItemStatus {
  WAITING
  SPEAKING
  DONE
  SKIPPED
}

enum ProposalStatus {
  ACTIVE
  PASSED
  BLOCKED
  WITHDRAWN
}

enum VoteType {
  AGREE
  STAND_ASIDE
  CONCERN
  BLOCK
}

enum IncidentStatus {
  OPEN
  INVESTIGATING
  RESOLVED
  DISMISSED
}

